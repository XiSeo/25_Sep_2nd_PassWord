`timescale 1ns / 1ps

module PassWord(
    input key_change,      // 进入更改密码状态（推上为高电平）
    input key_read,        // 读入密码信号（按下为高电平）
    input [9:0] key_input,  // 按键输入
    input key_delete,      // 删除上一位（按下为高电平）
    input key_enter,       // 确认键（按下为高电平）
    input key_restart,     // 管理员重启（按下为高电平）
    input clk_100MHz,
    output reg key_right ,      // 密码正确
    output reg key_wrong ,     // 密码错误
    output reg key_warn ,       // 报警状态
    output reg key_change_state = 0, // 修改状态指示灯
    output reg key_normal_state = 0, // 正常状态指示灯    
    output wire [7:0] ND_EN,       // 数码管显示使能信号
    output wire [7:0] ND_Num,      // 数码管显示数字
    output reg [9:0] LED,       //10s倒计时的led显示
    output RGB1_GREEN,            //报警状态呼吸灯1
    output RGB2_GREEN            //报警状态呼吸灯2
);

    // 状态定义
    localparam IDLE      = 3'd0; // 空闲/等待状态
    localparam INPUT1    = 3'd1; // 输入第一位
    localparam INPUT2    = 3'd2; // 输入第二位
    localparam INPUT3    = 3'd3; // 输入第三位
    localparam INPUT4    = 3'd4; // 输入第四位
    localparam ERROR     = 3'd5; // 错误提醒状态
    localparam WARNING   = 3'd6; // 报警状态
    localparam UNLOCKED  = 3'd7; // 开锁状态


    parameter PASSWORD_LENGTH = 4;
    reg [2:0] key_state_next = 0;
    reg [3:0] stored_password [0:PASSWORD_LENGTH-1]; // 存储密码
    reg [3:0] input_password [0:PASSWORD_LENGTH-1];  // 输入密码
    reg [2:0] key_state = 0; // 输入状态 (0-7)


    // 初始化密码数组
    initial begin
        stored_password[0] = 4'd0;
        stored_password[1] = 4'd0;
        stored_password[2] = 4'd0;
        stored_password[3] = 4'd0;
        input_password[0] = 4'd0;
        input_password[1] = 4'd0;
        input_password[2] = 4'd0;
        input_password[3] = 4'd0;
    end

    // 按键消抖寄存器
    reg [19:0] debounce_cnt = 20'd0;
    reg key_read_db, key_delete_db, key_enter_db, key_restart_db;
    reg key_read_r = 1'b0, key_delete_r = 1'b0, key_enter_r = 1'b0, key_restart_r = 1'b0;
    reg key_read_r_last, key_delete_r_last, key_enter_r_last, key_restart_r_last;

    // 边沿检测信号
    wire key_read_pos = key_read_r && !key_read_r_last;
    wire key_delete_pos = key_delete_r && !key_delete_r_last;
    wire key_enter_pos = key_enter_r && !key_enter_r_last;
    wire key_restart_pos = key_restart_r && !key_restart_r_last;

     // 错误计数器
    parameter tens = 1000000000;         //10s
    parameter twentys = 2000000000;      //20s
    reg [31:0] Count_CLK;               //计时单元

    // 错误计数器
    reg [1:0] wrong_times = 2'b0;

// 按键编码器
function automatic [3:0] key_encoder(input [9:0] keys);
    begin
         // 优先编码器，从最低位开始检测
        if (keys[0]) key_encoder = 4'd0;
        else if (keys[1]) key_encoder = 4'd1;
        else if (keys[2]) key_encoder = 4'd2;
        else if (keys[3]) key_encoder = 4'd3;
        else if (keys[4]) key_encoder = 4'd4;
        else if (keys[5]) key_encoder = 4'd5;
        else if (keys[6]) key_encoder = 4'd6;
        else if (keys[7]) key_encoder = 4'd7;
        else if (keys[8]) key_encoder = 4'd8;
        else if (keys[9]) key_encoder = 4'd9;
        else key_encoder = 4'hF;
        end
endfunction

    // 按键消抖处理
    always @(posedge clk_100MHz) begin
        key_read_db <= key_read;
        key_delete_db <= key_delete;
        key_enter_db <= key_enter;
        key_restart_db <= key_restart;

        key_read_r_last <= key_read_r;
        key_delete_r_last <= key_delete_r;
        key_enter_r_last <= key_enter_r;
        key_restart_r_last <= key_restart_r;
        // //仿真注释掉
        // if (debounce_cnt == 100000) begin
        //     debounce_cnt <= 20'd0;
        //     key_read_r <= key_read_db;
        //     key_delete_r <= key_delete_db;
        //     key_enter_r <= key_enter_db;
        //     key_restart_r <= key_restart_db;
        // end else begin
        //     debounce_cnt <= debounce_cnt + 20'd1;
        // end
        // //以上
    end
    //仿真用  仿真时要去掉消抖
    always @(posedge clk_100MHz ) begin
            key_read_r <= key_read_db;
            key_delete_r <=  key_delete_db;
            key_enter_r <= key_enter_db;
            key_restart_r <= key_restart_db;
    end

    // 时钟分频模块实例化
    wire clk10khz, clk2hz;
    CLK R_CLK (
        .clk_100MHz(clk_100MHz),
        .clk10khz(clk10khz),
        .clk2hz(clk2hz)
    );

    // 数码管显示模块实例化
    reg [4:0] num0, num1, num2, num3;
    reg [3:0] num_sparkle;

    Display R_Display (
        .Num10khz(clk10khz),
        .flicker2hz(clk2hz),
        .ND_EN(ND_EN),
        .ND_Num(ND_Num),
        .num0(num0),
        .num1(num1),
        .num2(num2),
        .num3(num3),
        .flicker(num_sparkle),
        .mode(key_state),
        .wrong_times(wrong_times)
    );
    //呼吸灯
    RGB R_RGB(
    .clk(clk_100MHz),
    .key_state(key_state),
    .RGB1_GREEN(RGB1_GREEN),   
    .RGB2_GREEN(RGB2_GREEN)
    );

    // 数码管显示更新逻辑
    always @(posedge clk_100MHz) begin
        if (!key_change) begin
            // 在输入状态下实时显示
            num0 <= input_password[0];
            num1 <= input_password[1];
            num2 <= input_password[2];
            num3 <= input_password[3];
        end else  begin
            // 在修改密码状态下显示存储的密码
            num0 <= stored_password[0];
            num1 <= stored_password[1];
            num2 <= stored_password[2];
            num3 <= stored_password[3];
        end 
    end

    // 状态转移逻辑
    always @(*) begin

        if (key_restart_pos) begin//重置
            key_state_next = IDLE;
            wrong_times = 2'b0;
            key_warn=0;
        end

        case(key_state)
            IDLE: begin
                if (key_read_pos) begin
                    key_state_next = INPUT1;
                end
            end

            INPUT1: begin
                if (key_delete_pos) begin
                    key_state_next = IDLE;
                end else if (key_read_pos) begin
                    key_state_next = INPUT2;
                end
            end

            INPUT2: begin
                if (key_delete_pos) begin
                    key_state_next = INPUT1;
                end else if (key_read_pos) begin
                    key_state_next = INPUT3;
                end
            end

            INPUT3: begin
                if (key_delete_pos) begin
                    key_state_next = INPUT2;
                end else if (key_read_pos) begin
                    key_state_next = INPUT4;
                end
            end

            INPUT4: begin
                if (key_delete_pos) begin
                    key_state_next = INPUT3;
                end else if (key_enter_pos) begin                  
                    if (key_change) begin
                        key_state_next = IDLE;
                    end else begin
                        if ((input_password[0] == stored_password[0]) &&
                            (input_password[1] == stored_password[1]) &&
                            (input_password[2] == stored_password[2]) &&
                            (input_password[3] == stored_password[3])) begin
                            key_state_next = UNLOCKED;
                        end else begin
                            if (wrong_times == 2'd3) begin
                                key_state_next = WARNING;
                                end    
                            else begin
                                key_state_next = ERROR;
                            end
                        end
                    end
                end
            end
            

            WARNING: begin
                if (key_restart_pos) begin
                    key_state_next = IDLE;
                end
            end

            ERROR: begin
                if(key_enter_pos) begin
                key_state_next = IDLE;
                end
            end

            UNLOCKED: begin
                if (key_enter_pos) begin
                    key_state_next = IDLE;
                end
            end
        endcase
    end

    always @(posedge clk_100MHz) begin
        key_change_state <= key_change;
        key_normal_state <= ~key_change;//引出外部接口  
        if(key_state == UNLOCKED)                      //20秒计时
         begin               
           if(Count_CLK > 1800000000) LED <= 10'b1111111111;
           else if(Count_CLK < 1800000000 & Count_CLK > 1600000000) LED <= 10'b0111111111;
           else if(Count_CLK < 1600000000 & Count_CLK > 1400000000) LED <= 10'b0011111111;
           else if(Count_CLK < 1400000000 & Count_CLK > 1200000000) LED <= 10'b0001111111;
           else if(Count_CLK < 1200000000 & Count_CLK > 1000000000) LED <= 10'b0000111111;
           else if(Count_CLK < 1000000000 & Count_CLK > 800000000) LED <= 10'b0000011111;
           else if(Count_CLK < 800000000 & Count_CLK > 600000000) LED <= 10'b0000001111;
           else if(Count_CLK < 600000000 & Count_CLK > 400000000) LED <= 10'b0000000111;
           else if(Count_CLK < 400000000 & Count_CLK > 200000000) LED <= 10'b0000000011;
           else if(Count_CLK < 200000000 & Count_CLK > 0) LED <= 10'b0000000001;
           else LED <= 10'b0000000000;
         end
       else                                          //10秒计时
         begin            
           if(Count_CLK > 900000000) LED <= 10'b1111111111;
           else if(Count_CLK < 900000000 & Count_CLK > 800000000) LED <= 10'b0111111111;
           else if(Count_CLK < 800000000 & Count_CLK > 700000000) LED <= 10'b0011111111;
           else if(Count_CLK < 700000000 & Count_CLK > 600000000) LED <= 10'b0001111111;
           else if(Count_CLK < 600000000 & Count_CLK > 500000000) LED <= 10'b0000111111;
           else if(Count_CLK < 500000000 & Count_CLK > 400000000) LED <= 10'b0000011111;
           else if(Count_CLK < 400000000 & Count_CLK > 300000000) LED <= 10'b0000001111;
           else if(Count_CLK < 300000000 & Count_CLK > 200000000) LED <= 10'b0000000111;
           else if(Count_CLK < 200000000 & Count_CLK > 100000000) LED <= 10'b0000000011;
           else if(Count_CLK < 100000000 & Count_CLK > 0) LED <= 10'b0000000001;
           else LED <= 10'b0000000000;
         end                     
          
        if(Count_CLK == 0)                        //跳转
         begin
           key_state_next <= IDLE;
         end

        case(key_state)
            IDLE: begin
                key_wrong<=1'b0;
                key_right <= 1'b0;
                key_warn <= 1'b0;
                LED <= 10'b0000000000;
                if (key_change) begin
                    // 进入修改密码模式
                if (key_read_pos) begin
                    // 开始输入密码
                    Count_CLK <= tens;
                    stored_password[0] <= key_encoder(key_input);
                    end
                end else if (key_read_pos) begin
                    // 开始输入密码
                    Count_CLK <= tens;
                    input_password[0] <= key_encoder(key_input);
                end
            end

            INPUT1: begin
               
                num_sparkle <= 4'b1000;
                Count_CLK <= Count_CLK - 1;
                if (key_delete_pos) begin
                    Count_CLK <= tens;
                    if (key_change) stored_password[0] <= 4'd0;
                    else input_password[0] <= 4'd0;
                end else if (key_read_pos) begin
                    Count_CLK <= tens;
                    if (key_change) begin
                        stored_password[1] <= key_encoder(key_input);
                    end else begin
                        input_password[1] <= key_encoder(key_input);
                    end
                end
            end

            INPUT2: begin
                num_sparkle <= 4'b0100;
                Count_CLK <= Count_CLK - 1;
                if (key_delete_pos) begin
                    Count_CLK <= tens;
                    if (key_change) stored_password[1] <= 4'd0;
                    else input_password[1] <= 4'd0;
                end else if (key_read_pos) begin
                    Count_CLK <= tens;
                    if (key_change) begin
                        stored_password[2] <= key_encoder(key_input);
                    end else begin
                        input_password[2] <= key_encoder(key_input);
                    end
                end
            end

            INPUT3: begin
                num_sparkle <= 4'b0010;
                Count_CLK <= Count_CLK - 1;
                if (key_delete_pos) begin
                    Count_CLK <= tens;
                    if (key_change) stored_password[2] <= 4'd0;
                    else input_password[2] <= 4'd0;
                end else if (key_read_pos) begin
                    Count_CLK <= tens;
                    if (key_change) begin
                        stored_password[3] <= key_encoder(key_input);
                    end else begin
                        input_password[3] <= key_encoder(key_input);
                    end
                end
            end

            INPUT4: begin
                num_sparkle <= 4'b0001;
                Count_CLK <= Count_CLK - 1;
                if (key_delete_pos) begin
                    Count_CLK <= tens;
                    if (key_change) stored_password[3] <= 4'd0;
                    else input_password[3] <= 4'd0;
                end else if (key_enter_pos) begin                  
                    if (key_change) begin
                        wrong_times<=0;
                    end else begin
                        if ((input_password[0] == stored_password[0]) &&
                            (input_password[1] == stored_password[1]) &&
                            (input_password[2] == stored_password[2]) &&
                            (input_password[3] == stored_password[3])) begin
                            Count_CLK<=twentys;
                        end else begin
                            wrong_times <= wrong_times + 2'b1;
                            if (wrong_times == 2'd3) begin
                                end    
                            else begin
                                Count_CLK<=tens;
                            end
                        end
                    end
                end
            end
            

            WARNING: begin
                key_wrong <= 1'b0;
                key_warn <= 1'b1;
                if (key_restart_pos) begin
                    wrong_times <= 2'b0;
                    key_warn <=0;
                end
            end

            ERROR: begin
                
                key_wrong <= 1'b1;
                Count_CLK <= Count_CLK - 1;
            end

            UNLOCKED: begin
                
                wrong_times <= 2'b0;
                key_right <= 1'b1;
                Count_CLK <= Count_CLK - 1;
                if (key_enter_pos) begin
                    key_right <= 1'b0;
                end
            end      
        endcase  
    end

    // 状态更新
    always @(posedge clk_100MHz) begin
        if(key_state!=key_state_next)
        key_state <= key_state_next;
    end
endmodule

module CLK(
    input clk_100MHz,
    output reg clk10khz,
    output reg clk2hz
);
    parameter N10k = 5000;        // 100MHz/10kHz/2 = 5000
    parameter N2 = 25000000;      // 100MHz/2Hz/2 = 25,000,000
    reg [27:0] Count10k = 0, Count2 = 0;

    always @(posedge clk_100MHz) begin
        Count10k <= Count10k + 1;
        Count2 <= Count2 + 1;

        if (Count10k < N10k) clk10khz <= 0;
        else begin
            clk10khz <= 1;
            if (Count10k >= 2 * N10k - 1) Count10k <= 0;
        end

        if (Count2 < N2) clk2hz <= 0;
        else begin
            clk2hz <= 1;
            if (Count2 >= 2 * N2 - 1) Count2 <= 0;
        end
    end
endmodule

module Display(
    input wire Num10khz,
    input wire flicker2hz,
    output reg [7:0] ND_EN,
    output reg [7:0] ND_Num,
    input wire [4:0] num0,
    input wire [4:0] num1,
    input wire [4:0] num2,
    input wire [4:0] num3,
    input wire [3:0] flicker,
    input wire [2:0] mode,
    input wire [1:0]wrong_times
);
    localparam IDLE = 3'd0, INPUT1 = 3'd1, INPUT2 = 3'd2, INPUT3 = 3'd3, 
               INPUT4 = 3'd4, ERROR =3'd5, WARNING = 3'd6, UNLOCKED = 3'd7;
               
    // 共阳极数码管编码 (0亮1灭)
    parameter N0 = 8'b11000000;  // 0
    parameter N1 = 8'b11111001;  // 1
    parameter N2 = 8'b10100100;  // 2
    parameter N3 = 8'b10110000;  // 3
    parameter N4 = 8'b10011001;  // 4
    parameter N5 = 8'b10010010;  // 5
    parameter N6 = 8'b10000010;  // 6
    parameter N7 = 8'b11111000;  // 7
    parameter N8 = 8'b10000000;  // 8
    parameter N9 = 8'b10010000;  // 9
    
    // 字母编码
    parameter VH = 8'b10001001;  // H
    parameter VE = 8'b10000110;  // E
    parameter VL = 8'b11000111;  // L
    parameter Vo = 8'b10100011;  // o
    parameter V_ = 8'b10111111;  // -
    parameter VC = 8'b11000110;  // C
    parameter VS = 8'b10010010;  // S
    parameter VU = 8'b11000001;  // U
    parameter VR = 8'b10001000;  // R
    parameter V0 = 8'b11111111;  //全灭

    reg [7:0] NUM0, NUM1, NUM2, NUM3;
    reg [2:0] ENcount = 0;
    reg [7:0]NUM4;
    always @* begin
        case (num0)
            0: NUM0 = N0; 1: NUM0 = N1; 2: NUM0 = N2; 3: NUM0 = N3; 4: NUM0 = N4; 5: NUM0 = N5;
            6: NUM0 = N6; 7: NUM0 = N7; 8: NUM0 = N8; 9: NUM0 = N9; default: NUM0 = V0;
        endcase
        case (num1)
            0: NUM1 = N0; 1: NUM1 = N1; 2: NUM1 = N2; 3: NUM1 = N3; 4: NUM1 = N4; 5: NUM1 = N5;
            6: NUM1 = N6; 7: NUM1 = N7; 8: NUM1 = N8; 9: NUM1 = N9; default: NUM1 = V0;
        endcase
        case (num2)
            0: NUM2 = N0; 1: NUM2 = N1; 2: NUM2 = N2; 3: NUM2 = N3; 4: NUM2 = N4; 5: NUM2 = N5;
            6: NUM2 = N6; 7: NUM2 = N7; 8: NUM2 = N8; 9: NUM2 = N9; default: NUM2 = V0;
        endcase
        case (num3)
            0: NUM3 = N0; 1: NUM3 = N1; 2: NUM3 = N2; 3: NUM3 = N3; 4: NUM3 = N4; 5: NUM3 = N5;
            6: NUM3 = N6; 7: NUM3 = N7; 8: NUM3 = N8; 9: NUM3 = N9; default: NUM3 = V0;
        endcase
        case(wrong_times)
            0: NUM4 = N0; 1: NUM4 = N1; 2: NUM4 = N2;3: NUM4 = N3;default: NUM4 = V0;
        endcase
    end

    always @(posedge Num10khz) begin
        ENcount <= ENcount + 1;
        case(mode)
            IDLE: begin
                case (ENcount)
                    0: begin ND_EN <= 8'b11111110; ND_Num <= V_; end
                    1: begin ND_EN <= 8'b11111101; ND_Num <= V_; end
                    2: begin ND_EN <= 8'b11111011; ND_Num <= V_; end
                    3: begin ND_EN <= 8'b11110111; ND_Num <= Vo; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= VL; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= VL; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= VE; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= VH; end
                endcase
            end
            INPUT1: begin
                    case (ENcount)
                    0: begin ND_EN <= (flicker2hz || !flicker[3]) ? 8'b11110111 : 8'b11111111;ND_Num <= NUM0; end
                    1: begin ND_EN <= 8'b11111011; ND_Num <= V0; end
                    2: begin ND_EN <= 8'b11111101; ND_Num <= V0; end
                    3: begin ND_EN <= 8'b11111110; ND_Num <= V0; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= V0; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= V0; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= V0; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= V0; end
                    endcase
            end
            INPUT2: begin
                    case (ENcount)
                    0: begin ND_EN <= 8'b11110111; ND_Num <= NUM0; end
                    1: begin ND_EN <= (flicker2hz || !flicker[2]) ? 8'b11111011 : 8'b11111111;ND_Num <= NUM1; end
                    2: begin ND_EN <= 8'b11111101; ND_Num <= V0; end
                    3: begin ND_EN <= 8'b11111110; ND_Num <= V0; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= V0; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= V0; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= V0; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= V0; end
                    endcase
            end
            INPUT3: begin
                    case (ENcount)
                    0: begin ND_EN <= 8'b11110111; ND_Num <= NUM0; end
                    1: begin ND_EN <= 8'b11111011; ND_Num <= NUM1; end
                    2: begin ND_EN <= (flicker2hz || !flicker[1]) ? 8'b11111101 : 8'b11111111;ND_Num <= NUM2;end
                    3: begin ND_EN <= 8'b11111110; ND_Num <= V0; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= V0; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= V0; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= V0; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= V0; end
                    endcase
            end
            INPUT4: begin
                    case (ENcount)
                    0: begin ND_EN <= 8'b11110111; ND_Num <= NUM0; end
                    1: begin ND_EN <= 8'b11111011; ND_Num <= NUM1; end
                    2: begin ND_EN <= 8'b11111101; ND_Num <= NUM2; end
                    3: begin ND_EN <= (flicker2hz || !flicker[0]) ? 8'b11111110 : 8'b11111111;ND_Num <= NUM3;end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= V0; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= V0; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= V0; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= V0; end
                    endcase
            end

            ERROR: begin
                case (ENcount)
                    0: begin ND_EN <= 8'b11111110; ND_Num <= NUM4; end
                    1: begin ND_EN <= 8'b11111101; ND_Num <= V_; end
                    2: begin ND_EN <= 8'b11111011; ND_Num <= V_; end
                    3: begin ND_EN <= 8'b11110111; ND_Num <= VR; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= Vo; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= VR; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= VR; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= VE; end
                endcase
            end

            UNLOCKED: begin
                case (ENcount)
                    0: begin ND_EN <= 8'b11111110; ND_Num <= VS; end
                    1: begin ND_EN <= 8'b11111101; ND_Num <= VS; end
                    2: begin ND_EN <= 8'b11111011; ND_Num <= VE; end
                    3: begin ND_EN <= 8'b11110111; ND_Num <= VC; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= VC; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= VU; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= VS; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= V0; end
                endcase
            end
            WARNING: begin
                case (ENcount)
                    0: begin ND_EN <= 8'b11111110; ND_Num <= V0; end
                    1: begin ND_EN <= 8'b11111101; ND_Num <= V0; end
                    2: begin ND_EN <= 8'b11111011; ND_Num <= V0; end
                    3: begin ND_EN <= 8'b11110111; ND_Num <= V0; end
                    4: begin ND_EN <= 8'b11101111; ND_Num <= V0; end
                    5: begin ND_EN <= 8'b11011111; ND_Num <= VE; end
                    6: begin ND_EN <= 8'b10111111; ND_Num <= VE; end
                    7: begin ND_EN <= 8'b01111111; ND_Num <= VE; end
                endcase
            end
        endcase
        if (ENcount >= 7) ENcount <= 0;
    end
endmodule

module RGB(
    input clk,
    input [2:0] key_state,
    output wire RGB1_GREEN,
    output wire RGB2_GREEN
    );
    
    localparam WARNING = 3'd6;
    
    // 参数定义 - 用户可配置
    parameter CLK_FREQ = 100_000_000;   // 输入时钟频率
    parameter PWM_FREQ = 2_000;         // PWM频率 (2kHz)
    parameter BREATH_FREQ = 2;          // 呼吸频率 (2Hz, 完成一呼一吸2秒)
    
    // 计算常数
    localparam PWM_CNT_MAX = (CLK_FREQ / PWM_FREQ) - 1;
    localparam PWM_CNT_WIDTH = $clog2(PWM_CNT_MAX);
    localparam BREATH_STEP = (CLK_FREQ / BREATH_FREQ) / 512; // 亮度分辨率256*2
    localparam BREATH_CNT_WIDTH = $clog2(BREATH_STEP);

    // 内部寄存器
    reg [PWM_CNT_WIDTH-1:0] pwm_counter = 0;
    reg [BREATH_CNT_WIDTH-1:0] breath_counter = 0;
    reg [7:0] brightness = 0;
    reg direction = 0; // 0:递增, 1:递减

    // PWM计数器
    always @(posedge clk) begin
        if (pwm_counter >= PWM_CNT_MAX)
            pwm_counter <= 0;
        else
            pwm_counter <= pwm_counter + 1;
    end

    // 呼吸亮度发生器
    always @(posedge clk) begin
        if(key_state == WARNING) begin
        breath_counter <= breath_counter + 1;
        
        if (breath_counter >= BREATH_STEP) begin
                breath_counter <= 0;

                if (direction == 0) begin
                    if (brightness < 255)
                        brightness <= brightness + 1;
                    else
                        direction <= 1;
                end else begin
                    if (brightness > 0)
                        brightness <= brightness - 1;
                    else
                        direction <= 0;
                end
            end
        end
        else begin
            brightness <= 0;
        end
    end

    // PWM比较输出
    assign RGB1_GREEN = (pwm_counter < brightness);
    assign RGB2_GREEN = (pwm_counter < brightness);

endmodule
