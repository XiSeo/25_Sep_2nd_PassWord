`timescale 1ns / 1ps

module PassWord(
    input key_change,      // 进入更改密码状态
    input key_read,        // 读入密码信号
    input [9:0] key_input, // 按键输入
    input key_delete,      // 删除上一位
    input key_enter,       // 确认键
    input key_restart,     // 管理员重启
    input clk_100MHz,
    output reg key_right = 0,      // 密码正确
    output reg key_wrong = 0,      // 密码错误
    output reg key_warn = 0,       // 报警状态
    output reg key_change_state = 0, // 修改状态指示灯
    output reg key_normal_state = 0, // 正常状态指示灯
    output reg [2:0] key_state=0// 输入状态 (0-6)

    output reg LED_4=1,             // 锁状态信号，LED4亮表示锁处于关闭状态
    output wire [7:0] ND_EN,        // 数码管显示使能信号
    output wire [7:0] ND_Num        // 数码管显示数字

);

    // 状态定义
    localparam IDLE      = 3'd0; // 空闲/等待状态
    localparam INPUT1    = 3'd1; // 输入第一位
    localparam INPUT2    = 3'd2; // 输入第二位
    localparam INPUT3    = 3'd3; // 输入第三位
    localparam INPUT4    = 3'd4; // 输入第四位
    localparam WARNING   = 3'd5; //报警状态
    localparam UNLOCKED  = 3'd6; // 开锁状态（新增状态）
    
    parameter PASSWORD_LENGTH = 4;    
    reg [2:0] key_state_next = 0; 

    reg [3:0] stored_password [0:PASSWORD_LENGTH-1]; // 存储密码
    reg [3:0] input_password [0:PASSWORD_LENGTH-1];  // 输入密码

    //按键取反
    wire key_change_in=~key_change;
    wire key_read_in=~key_read;
    wire key_delete_in=~key_delete;
    wire key_enter_in=~key_enter;
    wire key_restart_in=~key_restart;
    
    // 初始化密码数组
    initial begin
        stored_password[0] = 4'd0;
        stored_password[1] = 4'd0;
        stored_password[2] = 4'd0;
        stored_password[3] = 4'd0;
        
        input_password[0] = 4'd0;
        input_password[1] = 4'd0;
        input_password[2] = 4'd0;
        input_password[3] = 4'd0;
    end
    
    // 按键消抖寄存器
    reg [19:0] debounce_cnt = 20'd0; // 20ms消抖计数器 (2,000,000 cycles @ 100MHz)
    reg [4:0] key_sync=5'b11111; // 同步寄存器
    reg key_read_db, key_delete_db, key_enter_db, key_restart_db, key_change_db;
    reg key_read_r = 1'b0;   // 消抖后的读信号
    reg key_delete_r = 1'b0; // 消抖后的删除信号
    reg key_enter_r = 1'b0;  // 消抖后的确认信号
    reg key_restart_r = 1'b0; // 消抖后的重启信号
    reg key_change_r = 1'b0; // 消抖后的更改密码信号
    
    // 边沿检测寄存器
    reg key_read_r_last, key_delete_r_last, key_enter_r_last, key_restart_r_last, key_change_r_last;
    
    // 边沿检测信号
    wire key_read_pos = key_read_r && !key_read_r_last;
    wire key_delete_pos = key_delete_r && !key_delete_r_last;
    wire key_enter_pos = key_enter_r && !key_enter_r_last;
    wire key_restart_pos = key_restart_r && !key_restart_r_last;
    wire key_change_pos = key_change_r && !key_change_r_last;
    
    // 计时器
    reg [26:0] timer_10s = 27'd0;   // 10秒计时器 (1,000,000,000 cycles)
    reg [27:0] timer_20s = 28'd0;   // 20秒计时器 (2,000,000,000 cycles)
    wire timer_10s_done = (timer_10s == 27'd999); // 仿真用：1ms超时
    wire timer_20s_done = (timer_20s == 28'd999); // 仿真用：1ms超时
    // 真实值（注释掉仿真用的值）
    // wire timer_10s_done = (timer_10s == 27'd999_999_999); // 10秒超时
    // wire timer_20s_done = (timer_20s == 28'd1_999_999_999); // 20秒超时

    // 错误计数器
    reg [1:0] wrong_times = 2'b0; // 0-3次错误计数
    
    // 按键编码器
    function automatic [3:0] key_encoder(input [9:0] keys);
        begin
            case(keys)
                10'b0000000001: key_encoder = 4'd0;  // 按键0
                10'b0000000010: key_encoder = 4'd1;  // 按键1
                10'b0000000100: key_encoder = 4'd2;  // 按键2
                10'b0000001000: key_encoder = 4'd3;  // 按键3
                10'b0000010000: key_encoder = 4'd4;  // 按键4
                10'b0000100000: key_encoder = 4'd5;  // 按键5
                10'b0001000000: key_encoder = 4'd6;  // 按键6
                10'b0010000000: key_encoder = 4'd7;  // 按键7
                10'b0100000000: key_encoder = 4'd8;  // 按键8
                10'b1000000000: key_encoder = 4'd9;  // 按键9
                default: key_encoder = 4'hF;         // 无效输入
            endcase
        end
    endfunction
   
    // 按键消抖处理 (20ms)
    always @(posedge clk_100MHz) begin
        // 按键采样
        key_read_db <= key_read;
        key_delete_db <= key_delete;
        key_enter_db <= key_enter;
        key_restart_db <= key_restart;
        key_change_db <= key_change;
        
        // 边沿检测寄存器更新
        key_read_r_last <= key_read_r;
        key_delete_r_last <= key_delete_r;
        key_enter_r_last <= key_enter_r;
        key_restart_r_last <= key_restart_r;
        key_change_r_last <= key_change_r;
        
        // 消抖计数器
        if (debounce_cnt == 20'd1999) begin // 仿真用：20us消抖
            debounce_cnt <= 20'd0;
            
            // 更新消抖后的按键值
            key_read_r <= key_read_db;
            key_delete_r <= key_delete_db;
            key_enter_r <= key_enter_db;
            key_restart_r <= key_restart_db;
            key_change_r <= key_change_db;
        end else begin
            debounce_cnt <= debounce_cnt + 20'd1;
        end
    end

    // 时钟信号定义
    wire clk10khz, clk2hz;

    // 实例化时钟分频模块
    CLK CLK (
        .clk_100MHz(clk_100MHz),
        .clk10khz(clk10khz),
        .clk2hz(clk2hz)
    );


// 实例化数码管显示模块
    reg [4:0] num7, num6, num5, num4, num3, num2, num1, num0;
    reg [7:0] num_sparkle;          // 数码管闪烁控制
    Display Display (
        .ND_clk(clk_100MHz),
        .Num10khz(clk10khz),
        .flicker2hz(clk2hz),
        .ND_EN(ND_EN),
        .ND_Num(ND_Num),
        .num7(num7),
        .num6(num6),
        .num5(num5),
        .num4(num4),
        .num3(num3),
        .num2(num2),
        .num1(num1),
        .num0(num0),
        .flicker(num_sparkle),
        .mode(key_state)
    );

    // 数码管显示更新逻辑
    always@(posedge clk) begin        
        num3[3:0] <= input_password[3];  // 显示密码千位
        num2[3:0] <= input_password[2];   // 显示密码百位
        num1[3:0] <= input_password[1];    // 显示密码十位
        num0[3:0] <= input_password[0];    // 显示密码个位
    end


    
    // 主状态机
    always @(posedge clk_100MHz) begin
        // 状态指示灯
        key_change_state <= key_change;
        key_normal_state <= ~key_change;  // 改为按位取反
        
        // 计时器逻辑
        if ((key_state >= INPUT1) && (key_state <= INPUT4)) begin
            timer_10s <= timer_10s + 27'd1;
        end else begin
            timer_10s <= 27'd0;
        end
        
        if (key_state == UNLOCKED) begin
            timer_20s <= timer_20s + 28'd1;
        end else begin
            timer_20s <= 28'd0;
        end
    end
    
    // 状态转移逻辑
    always @* begin
        // 默认保持当前状态
        key_state_next = key_state;
        
        case(key_state)
            // 状态0: 空闲/等待状态
            IDLE: begin
                key_right = 1'b0;
                key_wrong = 1'b0;
                
                // 进入修改模式
                if (key_change_pos) begin
                    // 清空存储密码
                    stored_password[0] = 4'd0;
                    stored_password[1] = 4'd0;
                    stored_password[2] = 4'd0;
                    stored_password[3] = 4'd0;
                    key_state_next = INPUT1;
                end 
                // 开始输入密码
                else if (key_read_pos) begin
                    input_password[0] = key_encoder(key_input);
                    key_state_next = INPUT1;
                end
            end
            
            // 状态1: 输入第一位
            INPUT1: begin
                num_sparkle = 8'b0000_0001;  // 个位数码管闪烁
                if (timer_10s_done) begin
                    key_state_next = IDLE; // 10秒超时
                end
                else if (key_delete_pos) begin
                    key_state_next = IDLE; // 删除操作
                end
                else if (key_read_pos) begin
                    if (key_change) begin
                        stored_password[1] = key_encoder(key_input);
                    end else begin
                        input_password[1] = key_encoder(key_input);
                    end
                    key_state_next = INPUT2;
                end
            end
            
            // 状态2: 输入第二位
            INPUT2: begin
                num_sparkle = 8'b0000_0010;  // 十位数码管闪烁
                if (timer_10s_done) begin
                    key_state_next = IDLE; // 10秒超时
                end
                else if (key_delete_pos) begin
                    // 删除第二位，回退到状态1
                    key_state_next = INPUT1;
                    if (key_change) begin
                        stored_password[1] = 4'd0;
                    end else begin
                        input_password[1] = 4'd0;
                    end
                end
                else if (key_read_pos) begin
                    if (key_change) begin
                        stored_password[2] = key_encoder(key_input);
                    end else begin
                        input_password[2] = key_encoder(key_input);
                    end
                    key_state_next = INPUT3;
                end
            end
            
            // 状态3: 输入第三位
            INPUT3: begin
                num_sparkle = 8'b0000_0100;  // 百位数码管闪烁
                if (timer_10s_done) begin
                    key_state_next = IDLE; // 10秒超时
                end
                else if (key_delete_pos) begin
                    // 删除第三位，回退到状态2
                    key_state_next = INPUT2;
                    if (key_change) begin
                        stored_password[2] = 4'd0;
                    end else begin
                        input_password[2] = 4'd0;
                    end
                end
                else if (key_read_pos) begin
                    if (key_change) begin
                        stored_password[3] = key_encoder(key_input);
                    end else begin
                        input_password[3] = key_encoder(key_input);
                    end
                    key_state_next = INPUT4;
                end
            end
            
            // 状态4: 输入第四位
            INPUT4: begin
                num_sparkle = 8'b0000_1000;  // 千位数码管闪烁
                if (timer_10s_done) begin
                    key_state_next = IDLE; // 10秒超时
                end
                else if (key_delete_pos) begin
                    // 删除第四位，回退到状态3
                    key_state_next = INPUT3;
                    if (key_change) begin
                        stored_password[3] = 4'd0;
                    end else begin
                        input_password[3] = 4'd0;
                    end
                end
                else if (key_enter_pos) begin
                    // 修改密码模式
                    if (key_change) begin
                        key_state_next = IDLE; // 修改完成
                    end 
                    // 验证密码模式
                    else begin
                        // 检查密码
                        if ((input_password[0] == stored_password[0]) &&
                            (input_password[1] == stored_password[1]) &&
                            (input_password[2] == stored_password[2]) &&
                            (input_password[3] == stored_password[3])) 
                        {
                            key_right = 1'b1;
                            key_wrong = 1'b0;
                            wrong_times = 2'b0; // 重置错误计数器
                            key_state_next = UNLOCKED; // 进入开锁状态
                            num_sparkle=8'b0000_0000;  // 默认不闪烁
                        end else begin
                            key_right = 1'b0;
                            key_wrong = 1'b1;
                            wrong_times = wrong_times + 2'b1;
                            num_sparkle=8'b0000_0000;  // 默认不闪烁
                            // 检查错误次数
                            if (wrong_times == 2'd2) begin // 第三次错误
                                key_state_next = WARNING; // 进入报警状态
                            end
                            else begin
                                key_state_next = IDLE; // 回到空闲状态
                            }
                        end
                    end
                end
            end

            WARNING:begin
                key_warn = 1'b1;
                // 报警状态处理
                if (key_restart_pos) begin
                    key_warn = 1'b0;
                    key_state_next = IDLE;
                    wrong_times = 2'b0;
                end
            end
            
            // 状态6: 开锁状态（新增）
            UNLOCKED: begin
                key_right = 1'b1;
                // 20秒超时或按下确定键返回空闲状态
                if (timer_20s_done || key_enter_pos) begin
                    key_right = 1'b0;
                    key_state_next = IDLE;
                end
            end
            
            default: key_state_next = IDLE;
        endcase
    end

    // 只在状态变化时更新状态寄存器，减少不必要的触发
    always @(posedge clk_100MHz) begin
        if (key_state != key_state_next) begin
            key_state <= key_state_next;
            
            // 状态变化时清空输出
            if (key_state_next != UNLOCKED) begin
                key_right <= 1'b0;
            end
            if (key_state_next != WARNING) begin
                key_warn <= 1'b0;
            end
            key_wrong <= 1'b0; // 错误信号只在一个周期有效
        end
    end

endmodule


module CLK(
    input clk_100MHz,      // 输入100MHz时钟信号（XC7A100T默认时钟频率）
    output reg clk10khz,  // 输出10kHz时钟信号
    output reg clk2hz     // 输出2Hz时钟信号
);

    // 分频系数定义，用于生成不同频率的时钟（基于100MHz时钟）
    parameter N10k = 5000;        // 10kHz分频系数 (100MHz / (2 * 10kHz) = 5000)
    parameter N2 = 25000000;      // 2Hz分频系数 (100MHz / (2 * 2Hz) = 25000000)
    
    // 计数器寄存器，用于每个频率的分频计数
    reg [27:0] Count10k = 0;   // 10kHz时钟分频计数器
    reg [27:0] Count2 = 0;     // 2Hz时钟分频计数器
    
    // 时钟分频逻辑：在100MHz时钟的每个上升沿执行
    always @(posedge clk100mhz)  
    begin
        // 所有计数器递增
        Count10k <= Count10k + 1;
        Count2 <= Count2 + 1;

        // 10kHz时钟生成逻辑（占空比50%）
        if (Count10k < N10k) 
            clk10khz <= 0;        // 前半周期输出低电平
        else 
        begin
            clk10khz <= 1;        // 后半周期输出高电平
            if (Count10k >= 2 * N10k - 1) 
                Count10k <= 0;    // 计数器复位，开始新周期
        end
    
        // 2Hz时钟生成逻辑（占空比50%）
        if (Count2 < N2) 
            clk2hz <= 0;          // 前半周期输出低电平
        else 
        begin
            clk2hz <= 1;          // 后半周期输出高电平
            if (Count2 >= 2 * N2 - 1) 
                Count2 <= 0;      // 计数器复位，开始新周期
        end       
    end

endmodule

module Display(
    input wire ND_clk,
    input wire Num10khz,
    input wire flicker2hz,
    output reg [7:0] ND_EN,
    output reg [7:0] ND_Num,
    input wire [4:0] num7,
    input wire [4:0] num6,
    input wire [4:0] num5,
    input wire [4:0] num4,
    input wire [4:0] num3,
    input wire [4:0] num2,
    input wire [4:0] num1,
    input wire [4:0] num0,
    input wire [7:0] flicker,
    input wire [3:0] mode
);
    
    // 数码管段码定义（共阳极，低电平点亮）
    parameter N0 = 8'b0000_0011;
    parameter N1 = 8'b1001_1111;
    parameter N2 = 8'b0010_0101;
    parameter N3 = 8'b0000_1101;
    parameter N4 = 8'b1001_1001;
    parameter N5 = 8'b0100_1001;
    parameter N6 = 8'b0100_0001;
    parameter N7 = 8'b0001_1111;
    parameter N8 = 8'b0000_0001;
    parameter N9 = 8'b0000_1001;
    
    parameter VA = 8'b0001_0001;
    parameter VC = 8'b0110_0011;
    parameter VE = 8'b0110_0001;
    parameter VH = 8'b1001_0001;
    parameter VL = 8'b1110_0011;
    parameter VU = 8'b1000_0011;
    parameter Vo = 8'b0000_0011;
    parameter Vr = 8'b1111_0101;
    parameter VS = 8'b0100_1001;
    parameter V0 = 8'b1111_1111;
    parameter V_ = 8'b1111_1101;
    
    reg [7:0] NUM0, NUM1, NUM2, NUM3, NUM4, NUM5, NUM6, NUM7;
    reg [2:0] ENcount = 0;
    
    // 段码转换
    always @(*) begin
        case (num0)
            5'b00000: NUM0 = N0; 5'b00001: NUM0 = N1;
            5'b00010: NUM0 = N2; 5'b00011: NUM0 = N3;
            5'b00100: NUM0 = N4; 5'b00101: NUM0 = N5;
            5'b00110: NUM0 = N6; 5'b00111: NUM0 = N7;
            5'b01000: NUM0 = N8; 5'b01001: NUM0 = N9;
            default: NUM0 = V0;
        endcase
        
        case (num1)
            5'b00000: NUM1 = N0; 5'b00001: NUM1 = N1;
            5'b00010: NUM1 = N2; 5'b00011: NUM1 = N3;
            5'b00100: NUM1 = N4; 5'b00101: NUM1 = N5;
            5'b00110: NUM1 = N6; 5'b00111: NUM1 = N7;
            5'b01000: NUM1 = N8; 5'b01001: NUM1 = N9;
            default: NUM1 = V0;
        endcase
        
        case (num2)
            5'b00000: NUM2 = N0; 5'b00001: NUM2 = N1;
            5'b00010: NUM2 = N2; 5'b00011: NUM2 = N3;
            5'b00100: NUM2 = N4; 5'b00101: NUM2 = N5;
            5'b00110: NUM2 = N6; 5'b00111: NUM2 = N7;
            5'b01000: NUM2 = N8; 5'b01001: NUM2 = N9;
            default: NUM2 = V0;
        endcase
        
        case (num3)
            5'b00000: NUM3 = N0; 5'b00001: NUM3 = N1;
            5'b00010: NUM3 = N2; 5'b00011: NUM3 = N3;
            5'b00100: NUM3 = N4; 5'b00101: NUM3 = N5;
            5'b00110: NUM3 = N6; 5'b00111: NUM3 = N7;
            5'b01000: NUM3 = N8; 5'b01001: NUM3 = N9;
            default: NUM3 = V0;
        endcase
    end
    
    // 数码管扫描
    always @(posedge Num10khz) begin
        ENcount <= ENcount + 1;
        
        case(mode)
            IDLE: begin // HELLO---
                case (ENcount)
                    3'b000: begin ND_EN <= 8'b11111110; ND_Num <= V_; end
                    3'b001: begin ND_EN <= 8'b11111101; ND_Num <= V_; end
                    3'b010: begin ND_EN <= 8'b11111011; ND_Num <= V_; end
                    3'b011: begin ND_EN <= 8'b11110111; ND_Num <= Vo; end
                    3'b100: begin ND_EN <= 8'b11101111; ND_Num <= VL; end
                    3'b101: begin ND_EN <= 8'b11011111; ND_Num <= VL; end
                    3'b110: begin ND_EN <= 8'b10111111; ND_Num <= VE; end
                    3'b111: begin ND_EN <= 8'b01111111; ND_Num <= VH; end
                endcase
            end
            
            INPUT1: begin // 密码输入
                        ND_EN <= (flicker2hz || !flicker[0]) ? 8'b11111110 : 8'b11111111;
                        ND_Num <= NUM0;
                    end
            INPUT2: begin        
                        ND_EN <= (flicker2hz || !flicker[1]) ? 8'b11111101 : 8'b11111111;
                        ND_Num <= NUM1;
                    end
            INPUT3: begin 
                        ND_EN <= (flicker2hz || !flicker[2]) ? 8'b11111011 : 8'b11111111;
                        ND_Num <= NUM2;
                    end
            INPUT4: begin 
                        ND_EN <= (flicker2hz || !flicker[3]) ? 8'b11110111 : 8'b11111111;
                        ND_Num <= NUM3;
                    end
                    
            
        UNLOCKED: begin // SUCCESS
                case (ENcount)
                    3'b000: begin ND_EN <= 8'b11111110; ND_Num <= VS; end
                    3'b001: begin ND_EN <= 8'b11111101; ND_Num <= VS; end
                    3'b010: begin ND_EN <= 8'b11111011; ND_Num <= VE; end
                    3'b011: begin ND_EN <= 8'b11110111; ND_Num <= VC; end
                    3'b100: begin ND_EN <= 8'b11101111; ND_Num <= VC; end
                    3'b101: begin ND_EN <= 8'b11011111; ND_Num <= VU; end
                    3'b110: begin ND_EN <= 8'b10111111; ND_Num <= VS; end
                    3'b111: begin ND_EN <= 8'b01111111; ND_Num <= VS; end
                endcase
            end
            
            default: begin
                ND_EN <= 8'b11111111;
                ND_Num <= V0;
            end
        endcase
        
        if (ENcount >= 7) ENcount <= 0;
    end
endmodule
