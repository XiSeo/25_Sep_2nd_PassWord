`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/08/29 19:37:15
// Design Name: 
// Module Name: PassWord
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
//工作部分流程  
//

module PassWord(
    input key_change,      //该按键下后进入更改密码的状态
    input key_read,        //该按键按下后进入读密码的状态
    input [9:0]key_input,  //当key_read为1将其中为1的值（高电平）读入密码
    input key_delete,      //该按键按下后回退到上一个状态（即删除一位密码）
    input key_enter,       //确定键
    input key_restart,     //管理员专用按键（当进入报警状态时按下可以回到等待状态）
    input clk_100MHz,
    output reg key_right,      //密码正确
    output reg key_wrong,      //密码错误
    output reg key_warn        //连续三次密码错误进入报警状态
);
    parameter PASSWORD_LENGTH =4;    
    reg  [3:0]stored_password[0:PASSWORD_LENGTH-1]='{default:4'd0};//存储的密码值（初省值各元素均为0，修改密码时可以直接修改）
    reg  [3:0]input_password[0:PASSWORD_LENGTH-1]='{default:4'd0}; //密码锁工作时输入的密码值（正常工作后续会和存储的密码比较）
    //消抖后按钮确实按下的对应寄存器需要有值的变化
    reg key_change_r=1'b0;//等于1表示进入改密码状态(已消抖)为0表示处于正常输入状态
    reg key_read_r=1'b0;//等于1表示进入读密码状态(已消抖)
    reg key_delete_r=1'b0;//等于1表示应执行删除密码操作(已消抖)
    reg key_enter_r=1'b0;    //等于1表示确定
    reg key_restart_r=1'b0;    //等于1表示重启
    reg key_state=1'd0;//为1正在输入第一位，为2第二位，以此类推
    reg count_10s ;  //10s计时器  为1计满
    reg count_10s_start;//10s计时器  为1开始计时
    reg count_20s;   //20s计时器  为1计满
    reg count_20s_start;//20s计时器  为1开始计时
    reg wrong_times=1'd0;//犯错次数


    //消抖模块输出连接到wire，然后在always中赋值给reg
    wire key_change_debounced;
    wire key_read_debounced;
    wire key_delete_debounced;
    wire key_enter_debounced;
    wire key_restart_debounced;

    wire count_10s_wire;

    //计时器实例化
    count_10s_timer timer_10s_inst (
        .clk(clk_100MHz),
        .count_10s_start(count_10s_start),
        .count_10s(count_10s_wire)
    );

    //消抖实例化
    button_debounce_single debounce_inst0 (
        .clk(clk_100MHz),
        .button_in(key_change),
        .button_press(key_change_debounced)
    );

    button_debounce_single debounce_inst1 (
        .clk(clk_100MHz),
        .button_in(key_read),
        .button_press(key_read_debounced)
    );

    button_debounce_single debounce_inst2 (
        .clk(clk_100MHz),
        .button_in(key_delete),
        .button_press(key_delete_debounced)
    );

    button_debounce_single debounce_inst3 (
        .clk(clk_100MHz),
        .button_in(key_enter),
        .button_press(key_enter_debounced)
    );

    button_debounce_single debounce_inst4 (
        .clk(clk_100MHz),
        .button_in(key_restart),
        .button_press(key_restart_debounced)
    );

    always @(posedge clk_100MHz) begin
        // 将按键消抖后的wire信号赋值给reg
        key_change_r <= key_change_debounced;
        key_read_r <= key_read_debounced;
        key_delete_r <= key_delete_debounced;
        key_enter_r <= key_enter_debounced;
        key_restart_r <= key_restart_debounced;

        //将10s计时器的wire信号赋值给reg
        count_10s <= count_10s_wire;
    end


    // 按键编码器
    function automatic [3:0] key_encoder(input [9:0] keys);
        begin
            case(keys)
                10'b0000_0000_01: key_encoder = 4'd0;  // 按键0
                10'b0000_0000_10: key_encoder = 4'd1;  // 按键1
                10'b0000_0001_00: key_encoder = 4'd2;  // 按键2
                10'b0000_0010_00: key_encoder = 4'd3;  // 按键3
                10'b0000_0100_00: key_encoder = 4'd4;  // 按键4
                10'b0000_1000_00: key_encoder = 4'd5;  // 按键5
                10'b0001_0000_00: key_encoder = 4'd6;  // 按键6
                10'b0010_0000_00: key_encoder = 4'd7;  // 按键7
                10'b0100_0000_00: key_encoder = 4'd8;  // 按键8
                10'b1000_0000_00: key_encoder = 4'd9;  // 按键9
                default: key_encoder = 4'hF;           // 无效输入
            endcase
        end
    endfunction
   

    //正常输密码输入第一位
    always @(posedge clk_100MHz&&key_state==0)begin
        if(key_change_r==0)begin
            count_10s_start<=1;
            if (key_read_r) begin
                input_password[key_state]<= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s==1) begin
                key_state<=0;
                count_10s_start<=0;
            end
            else;
        end
        //改密码
        else begin
                count_10s_start<=1;
                if (key_read_r) begin
                    stored_password[key_state]<= key_encoder(key_input);
                    key_state++;
                end
                else if (count_10s==1) begin
                        key_state<=0;
                        count_10s_start<=0;
                end
                else;
            end
    end
    //输入第二位
    always @(posedge clk_100MHz&&key_state==1)begin
        if(key_change==0)begin
            count_10s_start<=1;
            if(key_delete_r)begin
                key_state<=0;
                input_password[0]<=0;
            end
            else if (key_read_r) begin
                input_password[key_state]<= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s) begin
                key_state<=0;
                count_10s_start<=0;
            end
            else;
        end
        //改密码
        else begin
            count_10s_start=1;
            if(key_delete_r)begin
                key_state<=0;
                input_password[0]<=0;
            end
            else if (key_read_r) begin
                stored_password[key_state]= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s&&!key_delete_r) begin
                key_state<=0;
                count_10s_start<=0;
            end
            else;
        end 
    end
    //输入第三位
    always @(posedge clk_100MHz&&key_state==2)begin
        if(key_change==0)begin
            count_10s_start<=1;
            if(key_delete_r)begin
                key_state<=1;
                input_password[1]<=0;
            end
            else if (key_read_r) begin
                input_password[key_state]<= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s) begin
                key_state<=0;
                count_10s_start<=0;
            end
            else;
        end
        //改密码
        else begin
            count_10s_start=1;
            if(key_delete_r)begin
                key_state<=1;
                input_password[1]<=0;
            end
            else if (key_read_r) begin
                stored_password[key_state]= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s) begin
                key_state<=0;
                count_10s_start<=0;
            end
            else;
        end 
    end
    //输入第四位
    always @(posedge clk_100MHz&&key_state==3)begin
        if(key_change==0)begin
            count_10s_start<=1;
            if(key_delete_r)begin
                key_state<=2;
                input_password[2]<=0;
            end
            if (key_read_r&&!key_delete_r) begin
                input_password[key_state]<= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s&&!key_delete_r) begin
                key_state<=0;
                count_10s_start<=0;
            end
        end
        //改密码
        else begin
            count_10s_start=1;
            if(key_delete_r)begin
                key_state<=2;
                input_password[2]<=0;
            end
            if (key_read_r&&!key_delete_r) begin
                stored_password[key_state]= key_encoder(key_input);
                key_state++;
            end
            else if (count_10s&&!key_delete_r) begin
                key_state<=0;
                count_10s_start<=0;
            end
        end 
    end
    //密码输入完毕后确认比较
    always @(posedge clk_100MHz&&key_state==4)begin 
        if(wrong_times>=3) key_warn<=1;//警告状态
        else begin
            if (key_change_r==0) begin
                count_10s_start<=1;
                if(key_delete_r)begin
                    key_state<=3;
                    input_password[3]<=0;
                end
                else if (key_read_r) begin
                    input_password[key_state]<= key_encoder(key_input);
                    key_state++;
                end
                else if (count_10s) begin
                    key_state<=0;
                    count_10s_start<=0;
                end
                else;
            end
        else;//
        end

    end

    always @(posedge clk_100MHz&&count_10s_start==1) begin
        
    end//计时10s

endmodule

// 独立的单按钮消抖模块（上电自动复位）
module button_debounce_single (
    input wire clk,
    input wire button_in,
    output reg button_press
);

    parameter DEBOUNCE_TIME = 20;
    parameter CLK_FREQ = 100_000_000;
    localparam MAX_COUNT = (DEBOUNCE_TIME * CLK_FREQ) / 1000;

    // 上电自动复位信号生成
    reg [15:0] por_counter;  // 上电复位计数器
    wire rst;                // 内部复位信号

    // 生成上电自动复位信号
    assign rst = (por_counter != 16'hFFFF);  // 计数器未满时保持复位

    reg [31:0] count;
    reg button_prev;
    reg button_stable;
    reg button_stable_prev;
    
    always @(posedge clk) begin
        // 上电复位计数器逻辑
        if (por_counter < 16'hFFFF) begin
            por_counter <= por_counter + 1;
        end
        
        // 消抖逻辑（使用上电复位信号）
        if (rst) begin
            count <= 0;
            button_prev <= 0;
            button_stable <= 0;
            button_stable_prev <= 0;
            button_press <= 0;
        end else begin
            button_prev <= button_in;
            button_stable_prev <= button_stable;
            
            if (button_prev != button_in) begin
                count <= 0;
            end else if (count < MAX_COUNT) begin
                count <= count + 1;
            end else begin
                button_stable <= button_in;
            end
            
            if (button_stable) begin
                button_press <= 1'b1;
            end else begin
                button_press <= 1'b0;
            end
        end
    end

endmodule

module count_10s_timer (
    input wire clk,                 // 系统时钟
    input wire count_10s_start,     // 启动计时信号
    output reg count_10s            // 计时完成标志
);

// 参数定义
parameter CLK_FREQ = 100_000_000;   // 100MHz时钟频率
parameter COUNT_10S = 10;           // 10秒计时
localparam MAX_COUNT = CLK_FREQ * COUNT_10S - 1;  // 10秒对应的计数值
localparam PULSE_WIDTH = 10;        // 完成标志脉冲宽度（时钟周期数）

// 内部信号
reg [31:0] timer_counter;          // 计时计数器
reg count_10s_start_prev;          // 用于检测上升沿
wire count_10s_start_posedge;      // 启动信号的上升沿
reg counting;                      // 计时进行中标志
reg [3:0] pulse_counter;           // 完成脉冲计数器

// 检测count_10s_start的上升沿
assign count_10s_start_posedge = ~count_10s_start_prev & count_10s_start;

// 主计时逻辑
always @(posedge clk) begin
    // 保存上一个时钟周期的启动信号状态
    count_10s_start_prev <= count_10s_start;
    
    // 检测到启动信号的上升沿
    if (count_10s_start_posedge) begin
        // 开始计时
        timer_counter <= 0;
        counting <= 1'b1;
        count_10s <= 1'b0;
        pulse_counter <= 0;
    end 
    // 正在计时中
    else if (counting && (timer_counter < MAX_COUNT)) begin
        timer_counter <= timer_counter + 1;
        count_10s <= 1'b0;
    end 
    // 计时完成，产生脉冲
    else if (counting && (timer_counter >= MAX_COUNT)) begin
        if (pulse_counter < PULSE_WIDTH) begin
            count_10s <= 1'b1;          // 输出完成脉冲
            pulse_counter <= pulse_counter + 1;
        end else begin
            count_10s <= 1'b0;          // 脉冲结束
            counting <= 1'b0;           // 停止计时
            timer_counter <= MAX_COUNT; // 保持最大值
        end
    end
    // 空闲状态
    else begin
        count_10s <= 1'b0;
        counting <= 1'b0;
    end
end

endmodule
