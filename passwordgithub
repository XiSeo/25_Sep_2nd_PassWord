`timescale 1ns / 1ps

module PassWord(
    input rst_n,            // 复位信号
    input key_change,       // 进入更改密码状态
    input key_read,         // 读入密码
    input [9:0] key_input,  // 输入按键值
    input key_delete,       // 删除上一位
    input key_enter,        // 确认键
    input key_restart,      // 管理员重启
    input clk_100MHz,       // 主时钟
    output reg key_right,   // 密码正确
    output reg key_wrong,   // 密码错误
    output reg key_warn,    // 报警状态
    output reg key_change_state,  // 修改状态指示灯
    output reg key_normal_state,  // 正常状态指示灯
    output reg [2:0] key_state  // 输入状态 (0-4)
);

    parameter PASSWORD_LENGTH = 4;    
    parameter IDLE = 0, INPUT = 1, COMPARE = 2, CHANGE = 3, ALARM = 4;
    
    // 密码存储
    reg [3:0] stored_password [0:PASSWORD_LENGTH-1];
    reg [3:0] input_password [0:PASSWORD_LENGTH-1];
    
    // 按键消抖寄存器
    reg [2:0] key_read_db = 0;
    reg [2:0] key_delete_db = 0;
    reg [2:0] key_enter_db = 0;
    reg [2:0] key_restart_db = 0;
    reg [2:0] key_change_db = 0;
    
    // 按键有效信号
    wire key_read_pulse;
    wire key_delete_pulse;
    wire key_enter_pulse;
    wire key_restart_pulse;
    wire key_change_pulse;
    
    // 计时器
    reg [26:0] counter_10s = 0;
    reg [27:0] counter_20s = 0;
    wire timer_10s_done = (counter_10s == 1_000_000_000); // 10秒 (100MHz时钟)
    wire timer_20s_done = (counter_20s == 2_000_000_000); // 20秒
    
    // 错误计数器
    reg [1:0] wrong_times = 0;
    
    // 状态寄存器
    reg [2:0] current_state = IDLE;
    reg [2:0] next_state = IDLE;
    
    // 初始化密码为0000
    integer i;
    initial begin
        for (i = 0; i < PASSWORD_LENGTH; i = i + 1) begin
            stored_password[i] = 4'd0;
        end
    end

    // 按键消抖处理
    always @(posedge clk_100MHz) begin
        key_read_db <= {key_read_db[1:0], key_read};
        key_delete_db <= {key_delete_db[1:0], key_delete};
        key_enter_db <= {key_enter_db[1:0], key_enter};
        key_restart_db <= {key_restart_db[1:0], key_restart};
        key_change_db <= {key_change_db[1:0], key_change};
    end
    
    assign key_read_pulse = (key_read_db[2:1] == 2'b10);
    assign key_delete_pulse = (key_delete_db[2:1] == 2'b10);
    assign key_enter_pulse = (key_enter_db[2:1] == 2'b10);
    assign key_restart_pulse = (key_restart_db[2:1] == 2'b10);
    assign key_change_pulse = (key_change_db[2:1] == 2'b10);
    
    // 按键编码器
    function [3:0] key_encoder;
        input [9:0] keys;
        begin
            case(keys)
                10'b0000_0000_01: key_encoder = 4'd0;  // 0
                10'b0000_0000_10: key_encoder = 4'd1;  // 1
                10'b0000_0001_00: key_encoder = 4'd2;  // 2
                10'b0000_0010_00: key_encoder = 4'd3;  // 3
                10'b0000_0100_00: key_encoder = 4'd4;  // 4
                10'b0000_1000_00: key_encoder = 4'd5;  // 5
                10'b0001_0000_00: key_encoder = 4'd6;  // 6
                10'b0010_0000_00: key_encoder = 4'd7;  // 7
                10'b0100_0000_00: key_encoder = 4'd8;  // 8
                10'b1000_0000_00: key_encoder = 4'd9;  // 9
                default: key_encoder = 4'hF;           // 无效
            endcase
        end
    endfunction
    
    // 状态寄存器更新
    always @(posedge clk_100MHz or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    
    // 状态转移逻辑
    always @(*) begin
        next_state = current_state; // 默认保持当前状态
        
        case (current_state)
            IDLE: begin
                if (key_change_pulse) next_state = CHANGE;
                else if (key_read_pulse) next_state = INPUT;
            end
            
            INPUT: begin
                if (key_enter_pulse && key_state == 4) begin
                    next_state = COMPARE;
                end
                else if (key_delete_pulse && key_state > 0) begin
                    next_state = INPUT; // 保持状态但删除一位
                end
                else if (timer_10s_done) begin
                    next_state = IDLE; // 10秒无操作返回等待
                end
            end
            
            COMPARE: begin
                if (timer_20s_done) begin
                    next_state = IDLE; // 20秒无操作返回等待
                end
                else if (key_enter_pulse) begin
                    next_state = IDLE; // 用户确认返回等待
                end
            end
            
            CHANGE: begin
                if (key_enter_pulse && key_state == 4) begin
                    next_state = IDLE; // 密码修改完成
                end
                else if (key_delete_pulse && key_state > 0) begin
                    next_state = CHANGE; // 保持状态但删除一位
                end
                else if (timer_10s_done) begin
                    next_state = IDLE; // 10秒无操作返回等待
                end
            end
            
            ALARM: begin
                if (key_restart_pulse) next_state = IDLE; // 管理员重启
            end
        endcase
    end
    
    // 状态输出逻辑
    always @(posedge clk_100MHz or negedge rst_n) begin
        if (!rst_n) begin
            key_state <= 0;
            key_right <= 0;
            key_wrong <= 0;
            key_warn <= 0;
            key_change_state <= 0;
            key_normal_state <= 1;
            counter_10s <= 0;
            counter_20s <= 0;
            wrong_times <= 0;
            
            // 清空输入密码
            for (i = 0; i < PASSWORD_LENGTH; i = i + 1) begin
                input_password[i] <= 0;
            end
        end else begin
            // 状态指示灯
            key_change_state <= (current_state == CHANGE);
            key_normal_state <= (current_state == IDLE || current_state == INPUT);
            
            // 计时器逻辑
            if (current_state == INPUT || current_state == CHANGE) begin
                counter_10s <= counter_10s + 1;
            end else begin
                counter_10s <= 0;
            end
            
            if (current_state == COMPARE) begin
                counter_20s <= counter_20s + 1;
            end else begin
                counter_20s <= 0;
            end
            
            // 状态机输出
            case (current_state)
                IDLE: begin
                    key_state <= 0;
                    key_right <= 0;
                    key_wrong <= 0;
                    wrong_times <= 0; // 复位错误计数器
                    
                    // 清空输入密码
                    for (i = 0; i < PASSWORD_LENGTH; i = i + 1) begin
                        input_password[i] <= 0;
                    end
                end
                
                INPUT: begin
                    if (key_read_pulse && key_state < 4) begin
                        input_password[key_state] <= key_encoder(key_input);
                        key_state <= key_state + 1;
                        counter_10s <= 0;  // 重置超时计数器
                    end
                    else if (key_delete_pulse && key_state > 0) begin
                        key_state <= key_state - 1;
                        input_password[key_state-1] <= 0;
                        counter_10s <= 0;  // 重置超时计数器
                    end
                end
                
                COMPARE: begin
                    // 仅在进入状态时比较一次
                    if (key_state == 4) begin
                        if (input_password == stored_password) begin
                            key_right <= 1;
                            wrong_times <= 0;  // 重置错误计数器
                        end else begin
                            key_wrong <= 1;
                            wrong_times <= wrong_times + 1;
                            
                            // 检查错误次数
                            if (wrong_times >= 2) begin  // 第三次错误
                                key_warn <= 1;
                                next_state = ALARM;
                            end
                        end
                        key_state <= 0;  // 比较结束后复位状态
                    end
                end
                
                CHANGE: begin
                    if (key_read_pulse && key_state < 4) begin
                        stored_password[key_state] <= key_encoder(key_input);
                        key_state <= key_state + 1;
                        counter_10s <= 0;  // 重置超时计数器
                    end
                    else if (key_delete_pulse && key_state > 0) begin
                        key_state <= key_state - 1;
                        stored_password[key_state-1] <= 0;
                        counter_10s <= 0;  // 重置超时计数器
                    end
                end
                
                ALARM: begin
                    key_warn <= 1;
                    if (key_restart_pulse) begin
                        key_warn <= 0;
                        key_state <= 0;
                        wrong_times <= 0;
                    end
                end
            endcase
        end
    end
endmodule
